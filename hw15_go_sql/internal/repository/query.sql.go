// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const LinkOrderToProductByOrderId = `-- name: LinkOrderToProductByOrderId :many
select id, order_id, product_id, count from hw15_go_sql.link_order_to_product where order_id = $1
`

func (q *Queries) LinkOrderToProductByOrderId(ctx context.Context, orderID *int64) ([]*LinkOrderToProduct, error) {
	rows, err := q.db.Query(ctx, LinkOrderToProductByOrderId, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*LinkOrderToProduct{}
	for rows.Next() {
		var i LinkOrderToProduct
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ProductID,
			&i.Count,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const LinkOrderToProductCreate = `-- name: LinkOrderToProductCreate :one
insert into hw15_go_sql.link_order_to_product(order_id, product_id, count)
VALUES ($1, $2, $3) returning id
`

type LinkOrderToProductCreateParams struct {
	OrderID   *int64 `db:"order_id" json:"order_id"`
	ProductID *int64 `db:"product_id" json:"product_id"`
	Count     int64  `db:"count" json:"count"`
}

func (q *Queries) LinkOrderToProductCreate(ctx context.Context, arg LinkOrderToProductCreateParams) (int64, error) {
	row := q.db.QueryRow(ctx, LinkOrderToProductCreate, arg.OrderID, arg.ProductID, arg.Count)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const OrderById = `-- name: OrderById :one
select id, user_id, append_date, total_amount from hw15_go_sql.orders where id = $1 limit $2
`

type OrderByIdParams struct {
	ID    int64 `db:"id" json:"id"`
	Limit int64 `db:"limit" json:"limit"`
}

func (q *Queries) OrderById(ctx context.Context, arg OrderByIdParams) (*Order, error) {
	row := q.db.QueryRow(ctx, OrderById, arg.ID, arg.Limit)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AppendDate,
		&i.TotalAmount,
	)
	return &i, err
}

const OrderCreate = `-- name: OrderCreate :one
insert into hw15_go_sql.orders(user_id, total_amount)
VALUES ($1, $2) returning id
`

type OrderCreateParams struct {
	UserID      pgtype.UUID    `db:"user_id" json:"user_id"`
	TotalAmount pgtype.Numeric `db:"total_amount" json:"total_amount"`
}

func (q *Queries) OrderCreate(ctx context.Context, arg OrderCreateParams) (int64, error) {
	row := q.db.QueryRow(ctx, OrderCreate, arg.UserID, arg.TotalAmount)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const OrderUpdateTotalAmount = `-- name: OrderUpdateTotalAmount :one
update hw15_go_sql.orders set total_amount = $2 where id = $1 returning id
`

type OrderUpdateTotalAmountParams struct {
	ID          int64          `db:"id" json:"id"`
	TotalAmount pgtype.Numeric `db:"total_amount" json:"total_amount"`
}

func (q *Queries) OrderUpdateTotalAmount(ctx context.Context, arg OrderUpdateTotalAmountParams) (int64, error) {
	row := q.db.QueryRow(ctx, OrderUpdateTotalAmount, arg.ID, arg.TotalAmount)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const Orders = `-- name: Orders :many
select id, user_id, append_date, total_amount from hw15_go_sql.orders limit $1 offset $2
`

type OrdersParams struct {
	Limit  int64 `db:"limit" json:"limit"`
	Offset int64 `db:"offset" json:"offset"`
}

func (q *Queries) Orders(ctx context.Context, arg OrdersParams) ([]*Order, error) {
	rows, err := q.db.Query(ctx, Orders, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AppendDate,
			&i.TotalAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ProductCreate = `-- name: ProductCreate :one
insert into hw15_go_sql.products(name, price)
VALUES ($1, $2) returning id
`

type ProductCreateParams struct {
	Name  string         `db:"name" json:"name"`
	Price pgtype.Numeric `db:"price" json:"price"`
}

func (q *Queries) ProductCreate(ctx context.Context, arg ProductCreateParams) (int64, error) {
	row := q.db.QueryRow(ctx, ProductCreate, arg.Name, arg.Price)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const ProductUpdatePrice = `-- name: ProductUpdatePrice :one
update hw15_go_sql.products set price = $2 where id = $1 returning id
`

type ProductUpdatePriceParams struct {
	ID    int64          `db:"id" json:"id"`
	Price pgtype.Numeric `db:"price" json:"price"`
}

func (q *Queries) ProductUpdatePrice(ctx context.Context, arg ProductUpdatePriceParams) (int64, error) {
	row := q.db.QueryRow(ctx, ProductUpdatePrice, arg.ID, arg.Price)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const Products = `-- name: Products :many
select id, name, price from hw15_go_sql.products limit $1 offset $2
`

type ProductsParams struct {
	Limit  int64 `db:"limit" json:"limit"`
	Offset int64 `db:"offset" json:"offset"`
}

func (q *Queries) Products(ctx context.Context, arg ProductsParams) ([]*Product, error) {
	rows, err := q.db.Query(ctx, Products, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(&i.ID, &i.Name, &i.Price); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ProductsByIds = `-- name: ProductsByIds :many
select id, name, price from hw15_go_sql.products where id = ANY($1::bigint[]) limit $2
`

type ProductsByIdsParams struct {
	Column1 []int64 `db:"column_1" json:"column_1"`
	Limit   int64   `db:"limit" json:"limit"`
}

func (q *Queries) ProductsByIds(ctx context.Context, arg ProductsByIdsParams) ([]*Product, error) {
	rows, err := q.db.Query(ctx, ProductsByIds, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(&i.ID, &i.Name, &i.Price); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UserById = `-- name: UserById :one
select id, name, email, password from hw15_go_sql.users where id = $1 limit $2
`

type UserByIdParams struct {
	ID    pgtype.UUID `db:"id" json:"id"`
	Limit int64       `db:"limit" json:"limit"`
}

func (q *Queries) UserById(ctx context.Context, arg UserByIdParams) (*User, error) {
	row := q.db.QueryRow(ctx, UserById, arg.ID, arg.Limit)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Password,
	)
	return &i, err
}

const UserCreate = `-- name: UserCreate :one
insert into hw15_go_sql.users(name, email, password)
VALUES ($1, $2, $3) returning id
`

type UserCreateParams struct {
	Name     string `db:"name" json:"name"`
	Email    string `db:"email" json:"email"`
	Password string `db:"password" json:"password"`
}

func (q *Queries) UserCreate(ctx context.Context, arg UserCreateParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, UserCreate, arg.Name, arg.Email, arg.Password)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const Users = `-- name: Users :many
select id, name, email, password from hw15_go_sql.users limit $1 offset $2
`

type UsersParams struct {
	Limit  int64 `db:"limit" json:"limit"`
	Offset int64 `db:"offset" json:"offset"`
}

func (q *Queries) Users(ctx context.Context, arg UsersParams) ([]*User, error) {
	rows, err := q.db.Query(ctx, Users, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Password,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
